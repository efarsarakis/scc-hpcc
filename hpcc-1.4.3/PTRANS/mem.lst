%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /fs3/d59/d59/s1361615/isc14/scc-hpcc/hpcc-1.4.3/hpl/lib/arch/build/../../../../PTRANS/mem.c
Compiled : 2014-03-24  21:35:03
Compiler : Version 8.2.x.x
Ftnlx    : Version 8232 (libcif 82024)
Target   : x86-64
Command  : driver.cc -h cpu=ivybridge -h static -h network=aries
           -o ../../../../PTRANS/mem.o -c ../../../../PTRANS/mem.c
           -I ../../../../include -I ../../../include
           -I ../../../include/CrayX1 -D Add_ -D StringSunStyle
           -D F77_INTEGER=int -O 2 -h list=m -D LONG_IS_64BITS -h restrict=a
           -ibase-compiler /opt/cray/cce/8.2.1/CC/x86-64/compiler_include_base
           -isystem /opt/cray/cce/8.2.1/craylibs/x86-64/include
           -I /opt/gcc/4.4.4/snos/lib/gcc/x86_64-suse-linux/4.4.4/include
           -I /opt/gcc/4.4.4/snos/lib/gcc/x86_64-suse-linux/4.4.4/include-fixed
           -L /opt/cray/cce/8.2.1/CC/x86-64/lib/x86-64
           -W l,-rpath=/opt/cray/cce/8.2.1/CC/x86-64/lib/x86-64
           -L /opt/gcc/4.4.4/snos/lib64 -W l,-rpath=/opt/gcc/4.4.4/snos/lib64
           -L /opt/cray/cce/8.2.1/craylibs/x86-64
           -W l,-rpath=/opt/cray/cce/8.2.1/craylibs/x86-64 -lcraymath
           -lquadmath -lcraymp
           -I /opt/cray/rca/1.0.0-2.0500.41336.1.120.ari/include
           -I /opt/cray/alps/5.0.3-2.0500.8095.1.1.ari/include
           -I /opt/cray/xpmem/0.1-2.0500.41356.1.11.ari/include
           -I /opt/cray/gni-headers/3.0-1.0500.7161.11.4.ari/include
           -I /opt/cray/dmapp/6.0.1-1.0500.7263.9.31.ari/include
           -I /opt/cray/pmi/4.0.1-1.0000.9753.86.2.ari/include
           -I /opt/cray/ugni/5.0-1.0500.0.3.306.ari/include
           -I /opt/cray/udreg/2.3.2-1.0500.6756.2.10.ari/include
           -I /opt/cray-hss-devel/7.0.0/include
           -I /opt/cray/krca/1.0.0-2.0500.41867.2.75.ari/include
           -L /opt/cray/rca/1.0.0-2.0500.41336.1.120.ari/lib64
           -L /opt/cray/alps/5.0.3-2.0500.8095.1.1.ari/lib64
           -L /opt/cray/xpmem/0.1-2.0500.41356.1.11.ari/lib64
           -L /opt/cray/dmapp/6.0.1-1.0500.7263.9.31.ari/lib64
           -L /opt/cray/pmi/4.0.1-1.0000.9753.86.2.ari/lib64
           -L /opt/cray/ugni/5.0-1.0500.0.3.306.ari/lib64
           -L /opt/cray/udreg/2.3.2-1.0500.6756.2.10.ari/lib64
           -I /opt/cray/mpt/6.1.1/gni/mpich2-cray/81/include
           -I /opt/cray/libsci/12.1.2/CRAY/81/sandybridge/include
           -I /opt/fftw/3.3.0.4/sandybridge/include
           -I /opt/cray/rca/1.0.0-2.0500.41336.1.120.ari/include
           -I /opt/cray/alps/5.0.3-2.0500.8095.1.1.ari/include
           -I /opt/cray/xpmem/0.1-2.0500.41356.1.11.ari/include
           -I /opt/cray/gni-headers/3.0-1.0500.7161.11.4.ari/include
           -I /opt/cray/dmapp/6.0.1-1.0500.7263.9.31.ari/include
           -I /opt/cray/pmi/4.0.1-1.0000.9753.86.2.ari/include
           -I /opt/cray/ugni/5.0-1.0500.0.3.306.ari/include
           -I /opt/cray/udreg/2.3.2-1.0500.6756.2.10.ari/include
           -I /opt/cray-hss-devel/7.0.0/include
           -I /opt/cray/krca/1.0.0-2.0500.41867.2.75.ari/include

clx report
------------
Source   : /fs3/d59/d59/s1361615/isc14/scc-hpcc/hpcc-1.4.3/hpl/lib/arch/build/../../../../PTRANS/mem.c
Date     : 03/24/2014  21:35:03


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted               
     E - Cloned               f - fused
     G - Accelerated          g - partitioned
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
                              n - non-blocking remote transfer
                              p - partial
                              r - unrolled
                              s - shortloop
     V - Vectorized           w - unwound

     + - More messages listed at end of listing
     ------------------------------------------


    1.              /* -*- mode: C; tab-width: 2; indent-tabs-mode: nil; fill-column: 79; coding: iso-latin-1-unix -*- */
    2.              
    3.              #include <hpcc.h>
    4.              
    5.              static int
    6.              CheckNode(int imrow, int imcol, int nmat, int *mval, int *nval, int nbmat, int *mbval, int *nbval,
    7.                        int myrow, int mycol, int nprow, int npcol, long *maxMem) {
    8.                int i__, ii, m, n, mb, nb, ierr[1];
    9.                int lcm, np0, nq0, mp0, mq0, mg, ng, np, nq, mp, mq;
   10.                long isw, ipw, ipiw, ipa, ipc;
   11.              
   12.                *maxMem = 0;
   13.  + 1-------<   for (i__ = 0; i__ < nmat; ++i__) {
   14.    1             m = mval[i__];
   15.    1             n = nval[i__];
   16.    1         
   17.    1         /*           Make sure matrix information is correct */
   18.    1         
   19.    1               ierr[0] = 0;
   20.    1               if (m < 1) {
   21.    1                 ierr[0] = 1;
   22.    1               } else if (n < 1) {
   23.    1                 ierr[0] = 1;
   24.    1               }
   25.    1         
   26.    1               if (ierr[0] > 0) {
   27.    1                 continue;
   28.    1               }
   29.    1         
   30.  + 1 2-----<       for (ii = 0; ii < nbmat; ++ii) { /* Loop over different block sizes */
   31.    1 2       
   32.    1 2               mb = mbval[ii];
   33.    1 2               nb = nbval[ii];
   34.    1 2       
   35.    1 2       /*              Make sure blocking sizes are legal */
   36.    1 2               ierr[0] = 0;
   37.    1 2               if (mb < 1) {
   38.    1 2                 ierr[0] = 1;
   39.    1 2               } else if (nb < 1) {
   40.    1 2                 ierr[0] = 1;
   41.    1 2               }
   42.    1 2       
   43.    1 2       /*              Make sure no one had error */
   44.    1 2       
   45.    1 2               if (ierr[0] > 0) {
   46.    1 2                 continue;
   47.    1 2               }
   48.    1 2       
   49.  + 1 2               mp = numroc_(&m, &mb, &myrow, &imrow, &nprow);
   50.  + 1 2               mq = numroc_(&m, &mb, &mycol, &imcol, &npcol);
   51.  + 1 2               np = numroc_(&n, &nb, &myrow, &imrow, &nprow);
   52.  + 1 2               nq = numroc_(&n, &nb, &mycol, &imcol, &npcol);
   53.    1 2       
   54.  + 1 2               mg = iceil_(&m, &mb);
   55.  + 1 2               ng = iceil_(&n, &nb);
   56.    1 2       
   57.  + 1 2               mp0 = iceil_(&mg, &nprow) * mb;
   58.  + 1 2               mq0 = iceil_(&mg, &npcol) * mb;
   59.  + 1 2               np0 = iceil_(&ng, &nprow) * nb;
   60.  + 1 2               nq0 = iceil_(&ng, &npcol) * nb;
   61.    1 2       
   62.  + 1 2               lcm = ilcm_(&nprow, &npcol);
   63.    1 2               ipc = 1;
   64.    1 2               ipa = ipc + (long)np0 * (long)mq0;
   65.    1 2               ipiw = (long)mp0 * (long)nq0 + ipa;
   66.    1 2               ipw = ipiw;
   67.  + 1 2               isw = ipw + (long)(iceil_(&mg, &lcm) << 1) * (long)mb * (long)iceil_(&ng, &lcm) * (long)nb;
   68.    1 2       
   69.    1 2               if (*maxMem < isw) *maxMem = isw;
   70.    1 2----->       }
   71.    1------->   }
   72.                return 0;
   73.              }
   74.              
   75.              int
   76.              MaxMem(int nprocs, int imrow, int imcol, int nmat, int *mval, int *nval, int nbmat, int *mbval,
   77.                     int *nbval, int ngrids, int *npval, int *nqval, long *maxMem) {
   78.                int nprow, npcol, myrow, mycol;
   79.                int j, ierr[1];
   80.                long curMem;
   81.              
   82.                *maxMem = 0;
   83.  + 1-------<   for (j = 0; j < ngrids; ++j) {
   84.    1             nprow = npval[j];
   85.    1             npcol = nqval[j];
   86.    1         
   87.    1         /*        Make sure grid information is correct */
   88.    1         
   89.    1             ierr[0] = 0;
   90.    1             if (nprow < 1) {
   91.    1              ierr[0] = 1;
   92.    1             } else if (npcol < 1) {
   93.    1               ierr[0] = 1;
   94.    1             } else if (nprow * npcol > nprocs) {
   95.    1               ierr[0] = 1;
   96.    1             }
   97.    1         
   98.    1             if (ierr[0] > 0) {
   99.    1               continue;
  100.    1             }
  101.  + 1 2-----<     for (myrow = 0; myrow < nprow; myrow++)
  102.  + 1 2 3---<       for (mycol = 0; mycol < npcol; mycol++) {
  103.  + 1 2 3             CheckNode( imrow, imcol, nmat, mval, nval, nbmat, mbval, nbval, myrow, mycol, nprow,
  104.    1 2 3                        npcol, &curMem );
  105.    1 2 3             if (*maxMem < curMem) *maxMem = curMem;
  106.    1 2 3-->>       }
  107.    1------->   }
  108.                return 0;
  109.              }
  110.              
  111.              #ifdef HPCC_MEMMAIN
  112.              #include <stdio.h>
  113.              int iceil_(int *n,int *d) {return *n>0 ? (*n+*d-1)/ *d : *n/ *d;}
  114.              int numroc_(int *n, int *nb, int *iproc, int *isrcproc, int *nprocs) {
  115.                int ret_val, extrablks, mydist, nblocks;
  116.                mydist = (*nprocs + *iproc - *isrcproc) % *nprocs;
  117.                nblocks = *n / *nb;
  118.                ret_val = nblocks / *nprocs * *nb;
  119.                extrablks = nblocks % *nprocs;
  120.                if (mydist < extrablks) {
  121.                  ret_val += *nb;
  122.                } else if (mydist == extrablks) {
  123.                  ret_val += *n % *nb;
  124.                }
  125.                return ret_val;
  126.              }
  127.              int ilcm_(int *m, int *n) {
  128.                int ret_val;
  129.                int ia, iq, ir;
  130.                if (*m >= *n) {
  131.                  ia = *m;
  132.                  ret_val = *n;
  133.                } else {
  134.                  ia = *n;
  135.                  ret_val = *m;
  136.                }
  137.                for (;;) {
  138.                  iq = ia / ret_val;
  139.                  ir = ia - iq * ret_val;
  140.                  if (ir == 0) {
  141.                    ret_val = *m * *n / ret_val;
  142.                    return ret_val;
  143.                  }
  144.                  ia = ret_val;
  145.                  ret_val = ir;
  146.                }
  147.              }
  148.              int
  149.              main(int argc, char *argv[]) {
  150.                int n, nb, nprow, npcol, ng, lcm;
  151.                int nval[1], nbval[1];
  152.                long maxMem;
  153.              
  154.                if (argc <= 1) {
  155.                  printf( "Usage:\n%s n nb nprow npcol\n", argv[0] );
  156.                }
  157.              
  158.                if (argc <= 1 || sscanf( argv[1], "%d", &n  ) != 1 || n < 1)  n = 50000;
  159.                if (argc <= 2 || sscanf( argv[2], "%d", &nb ) != 1 || nb < 1) nb = 80;
  160.                if (argc <= 3 || sscanf( argv[3], "%d", &nprow ) != 1 || nprow < 1) nprow = 8;
  161.                if (argc <= 4 || sscanf( argv[4], "%d", &npcol ) != 1 || npcol < 1) npcol = nprow;
  162.              
  163.                nval[0] = n;
  164.                nbval[0] = nb;
  165.              
  166.                CheckNode( 0, 0, 1, nval, nval, 1, nbval, nbval, 0, 0, nprow, npcol, &maxMem );
  167.              
  168.                printf( "n=%d nb=%d nprow=%d npcol=%d lcm(nprow,npcol)=%d\n%ld\n", n, nb, nprow, npcol,
  169.                        ilcm_(&nprow, &npcol), maxMem );
  170.              
  171.                ng = iceil_(&n, &nb);
  172.                lcm = ilcm_(&nprow, &npcol);
  173.                printf( "%d %d %d\n", ng, lcm, (iceil_(&ng, &lcm) << 1) * nb * iceil_(&ng, &lcm) * nb );
  174.                printf( "%d %d\n", (iceil_(&ng, &lcm) << 1), iceil_(&ng, &lcm) );
  175.              
  176.                return 0;
  177.              }
  178.              #endif

CC-6287 CC: VECTOR File = mem.c, Line = 13 
  A loop was not vectorized because it contains a call to function "numroc_" on line 49.

CC-6287 CC: VECTOR File = mem.c, Line = 30 
  A loop was not vectorized because it contains a call to function "numroc_" on line 49.

CC-3021 CC: IPA File = mem.c, Line = 49 
  "numroc_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 50 
  "numroc_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 51 
  "numroc_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 52 
  "numroc_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 54 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 55 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 57 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 58 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 59 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 60 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 62 
  "ilcm_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 67 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 67 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = mem.c, Line = 83 
  A loop was not vectorized because it contains a call to function "CheckNode" on line 103.

CC-6287 CC: VECTOR File = mem.c, Line = 101 
  A loop was not vectorized because it contains a call to function "CheckNode" on line 103.

CC-6287 CC: VECTOR File = mem.c, Line = 102 
  A loop was not vectorized because it contains a call to function "CheckNode" on line 103.

CC-3005 CC: IPA File = mem.c, Line = 103 
  "CheckNode" (called from "MaxMem") was not inlined because the type of argument 13 does not match the corresponding type from the
  routine definition - RESTRICT qualifiers differ.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
