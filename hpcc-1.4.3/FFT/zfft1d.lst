%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /fs3/d59/d59/s1361615/isc14/scc-hpcc/hpcc-1.4.3/hpl/lib/arch/build/../../../../FFT/zfft1d.c
Compiled : 2014-03-24  21:35:16
Compiler : Version 8.2.x.x
Ftnlx    : Version 8232 (libcif 82024)
Target   : x86-64
Command  : driver.cc -h cpu=ivybridge -h static -h network=aries
           -o ../../../../FFT/zfft1d.o -c ../../../../FFT/zfft1d.c
           -I ../../../../include -I ../../../include
           -I ../../../include/CrayX1 -D Add_ -D StringSunStyle
           -D F77_INTEGER=int -O 2 -h list=m -D LONG_IS_64BITS -h restrict=a
           -ibase-compiler /opt/cray/cce/8.2.1/CC/x86-64/compiler_include_base
           -isystem /opt/cray/cce/8.2.1/craylibs/x86-64/include
           -I /opt/gcc/4.4.4/snos/lib/gcc/x86_64-suse-linux/4.4.4/include
           -I /opt/gcc/4.4.4/snos/lib/gcc/x86_64-suse-linux/4.4.4/include-fixed
           -L /opt/cray/cce/8.2.1/CC/x86-64/lib/x86-64
           -W l,-rpath=/opt/cray/cce/8.2.1/CC/x86-64/lib/x86-64
           -L /opt/gcc/4.4.4/snos/lib64 -W l,-rpath=/opt/gcc/4.4.4/snos/lib64
           -L /opt/cray/cce/8.2.1/craylibs/x86-64
           -W l,-rpath=/opt/cray/cce/8.2.1/craylibs/x86-64 -lcraymath
           -lquadmath -lcraymp
           -I /opt/cray/rca/1.0.0-2.0500.41336.1.120.ari/include
           -I /opt/cray/alps/5.0.3-2.0500.8095.1.1.ari/include
           -I /opt/cray/xpmem/0.1-2.0500.41356.1.11.ari/include
           -I /opt/cray/gni-headers/3.0-1.0500.7161.11.4.ari/include
           -I /opt/cray/dmapp/6.0.1-1.0500.7263.9.31.ari/include
           -I /opt/cray/pmi/4.0.1-1.0000.9753.86.2.ari/include
           -I /opt/cray/ugni/5.0-1.0500.0.3.306.ari/include
           -I /opt/cray/udreg/2.3.2-1.0500.6756.2.10.ari/include
           -I /opt/cray-hss-devel/7.0.0/include
           -I /opt/cray/krca/1.0.0-2.0500.41867.2.75.ari/include
           -L /opt/cray/rca/1.0.0-2.0500.41336.1.120.ari/lib64
           -L /opt/cray/alps/5.0.3-2.0500.8095.1.1.ari/lib64
           -L /opt/cray/xpmem/0.1-2.0500.41356.1.11.ari/lib64
           -L /opt/cray/dmapp/6.0.1-1.0500.7263.9.31.ari/lib64
           -L /opt/cray/pmi/4.0.1-1.0000.9753.86.2.ari/lib64
           -L /opt/cray/ugni/5.0-1.0500.0.3.306.ari/lib64
           -L /opt/cray/udreg/2.3.2-1.0500.6756.2.10.ari/lib64
           -I /opt/cray/mpt/6.1.1/gni/mpich2-cray/81/include
           -I /opt/cray/libsci/12.1.2/CRAY/81/sandybridge/include
           -I /opt/fftw/3.3.0.4/sandybridge/include
           -I /opt/cray/rca/1.0.0-2.0500.41336.1.120.ari/include
           -I /opt/cray/alps/5.0.3-2.0500.8095.1.1.ari/include
           -I /opt/cray/xpmem/0.1-2.0500.41356.1.11.ari/include
           -I /opt/cray/gni-headers/3.0-1.0500.7161.11.4.ari/include
           -I /opt/cray/dmapp/6.0.1-1.0500.7263.9.31.ari/include
           -I /opt/cray/pmi/4.0.1-1.0000.9753.86.2.ari/include
           -I /opt/cray/ugni/5.0-1.0500.0.3.306.ari/include
           -I /opt/cray/udreg/2.3.2-1.0500.6756.2.10.ari/include
           -I /opt/cray-hss-devel/7.0.0/include
           -I /opt/cray/krca/1.0.0-2.0500.41867.2.75.ari/include

clx report
------------
Source   : /fs3/d59/d59/s1361615/isc14/scc-hpcc/hpcc-1.4.3/hpl/lib/arch/build/../../../../FFT/zfft1d.c
Date     : 03/24/2014  21:35:18


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted               
     E - Cloned               f - fused
     G - Accelerated          g - partitioned
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
                              n - non-blocking remote transfer
                              p - partial
                              r - unrolled
                              s - shortloop
     V - Vectorized           w - unwound

     + - More messages listed at end of listing
     ------------------------------------------


    1.                 /* -*- mode: C; tab-width: 2; indent-tabs-mode: nil; fill-column: 79; coding: iso-latin-1-unix -*- */
    2.                 /*
    3.                 C
    4.                 C     FFTE: A FAST FOURIER TRANSFORM PACKAGE
    5.                 C
    6.                 C     (C) COPYRIGHT SOFTWARE, 2000-2004, ALL RIGHTS RESERVED
    7.                 C                BY
    8.                 C         DAISUKE TAKAHASHI
    9.                 C         GRADUATE SCHOOL OF SYSTEMS AND INFORMATION ENGINEERING
   10.                 C         UNIVERSITY OF TSUKUBA
   11.                 C         1-1-1 TENNODAI, TSUKUBA, IBARAKI 305-8573, JAPAN
   12.                 C         E-MAIL: daisuke@cs.tsukuba.ac.jp
   13.                 C
   14.                 C
   15.                 C     1-D COMPLEX FFT ROUTINE
   16.                 C
   17.                 C     FORTRAN77 SOURCE PROGRAM
   18.                 C
   19.                 C     CALL ZFFT1D(A,N,IOPT,B)
   20.                 C
   21.                 C     A(N) IS COMPLEX INPUT/OUTPUT VECTOR (COMPLEX*16)
   22.                 C     B(N) IS WORK VECTOR (COMPLEX*16)
   23.                 C     N IS THE LENGTH OF THE TRANSFORMS (INTEGER*4)
   24.                 C       -----------------------------------
   25.                 C         N = (2**IP) * (3**IQ) * (5**IR)
   26.                 C       -----------------------------------
   27.                 C     IOPT = 0 FOR INITIALIZING THE COEFFICIENTS (INTEGER*4)
   28.                 C          = -1 FOR FORWARD TRANSFORM
   29.                 C          = +1 FOR INVERSE TRANSFORM
   30.                 C
   31.                 C     WRITTEN BY DAISUKE TAKAHASHI
   32.                 C
   33.                 */
   34.                 
   35.                 #include "hpccfft.h"
   36.                 
   37.                 #ifdef _OPENMP
   38.                 #include <omp.h>
   39.                 #endif
   40.                 
   41.                 int
   42.                 HPCC_ipow(int x, int p) {
   43.                   int i, r;
   44.                 
   45.                   if (1 == x || 0 == x) return x;
   46.                   if (0 == p) return 1;
   47.                   if (-1 == x) return (p & 1) ? -1 : 1;
   48.                   if (p < 0) return 0;
   49.                   r = 1;
   50.    D---------<>   for (i = 0; i < p; i++) r *= x;
   51.                   return r;
   52.                 }
   53.                 
   54.                 static int
   55.                 zfft1d0(fftw_complex *a1, fftw_complex *a2, fftw_complex *b, fftw_complex *c, fftw_complex *d,
   56.                   fftw_complex *w1, fftw_complex *w2, fftw_complex *ww1, fftw_complex *ww2, fftw_complex *ww3,
   57.                   fftw_complex *ww4, int n1, int n2, int m1, int m2, int *ip1, int *ip2) {
   58.                 
   59.                   int lda1, lda2, ldb, ldc, ldww1, ldww2, ldww3, ldww4;
   60.                   int ii, ij, ij0, ik, ir, is, jj, i, j;
   61.                   int tmin1, tmin2, itmp1;
   62.                   fftw_complex ztmp1, ztmp2, ztmp3, ztmp4;
   63.                 
   64.                   lda1 = n1;
   65.                   lda2 = n2;
   66.                   ldb = n1;
   67.                   ldc = n2 + FFTE_NP;
   68.                   ldww1 = m1;
   69.                   ldww2 = m1;
   70.                   ldww3 = m2;
   71.                   ldww4 = n1/m1;
   72.                 
   73.                 #ifdef _OPENMP
   74.                 #pragma omp for private(ij,ij0,ir,jj,i,j,ik,is,ztmp1,ztmp2,ztmp3,ztmp4,tmin1,tmin2,itmp1)
   75.                 #endif
   76.  + m----------<   for (ii = 0; ii < n1; ii += FFTE_NBLK) {
   77.  + m 2--------<     for (jj = 0; jj < n2; jj += FFTE_NBLK) {
   78.    m 2                tmin1 = ii + FFTE_NBLK;
   79.    m 2                V2MIN( tmin1, n1 );
   80.    m 2          
   81.  + m 2 3------<       for (i = ii; i < tmin1; ++i) {
   82.    m 2 3                tmin2 = jj + FFTE_NBLK;
   83.    m 2 3                V2MIN( tmin2, n2 );
   84.    m 2 3        
   85.  + m 2 3 r8---<         for (j = jj; j < tmin2; ++j) {
   86.    m 2 3 r8               c_assgn( ARR2D(c, j, i-ii, ldc), ARR2D(a1, i, j, lda1) );
   87.    m 2 3 r8--->         }
   88.    m 2 3------>       }
   89.    m 2-------->     }
   90.    m            
   91.    m                tmin1 = ii + FFTE_NBLK;
   92.    m                V2MIN( tmin1, n1 );
   93.  + m 2--------<     for (i = ii; i < tmin1; ++i)
   94.  + m 2 ------->       HPCC_fft235( PTR2D(c, 0, i-ii, ldc), d, w2, n2, ip2 );
   95.    m            
   96.    m D I------>     if (HPCC_ipow( 2, ip1[0] ) < FFTE_NBLK || HPCC_ipow( 2, ip2[0] ) < FFTE_NBLK) {
   97.    m                  itmp1 = n2 / m2;
   98.  + m 2--------<       for (is = 0; is < itmp1; ++is) {
   99.  + m 2 3------<         for (ik = 0; ik < m2; ++ik) {
  100.    m 2 3                  j = ik + is * m2;
  101.    m 2 3        
  102.    m 2 3                  tmin1 = ii + FFTE_NBLK;
  103.    m 2 3                  V2MIN( tmin1, n1 );
  104.  + m 2 3 r8---<           for (i = ii; i < tmin1; ++i) {
  105.    m 2 3 r8                 ir = i / m1;
  106.    m 2 3 r8                 ij = i % m1;
  107.    m 2 3 r8     
  108.    m 2 3 r8                 c_assgn(ztmp1, ARR2D(c, j, i-ii, ldc));
  109.    m 2 3 r8     
  110.    m 2 3 r8                 c_assgn(ztmp2, ARR2D(ww1, ij, ik, ldww1));
  111.    m 2 3 r8                 c_mul3v(ztmp3, ztmp1, ztmp2);
  112.    m 2 3 r8     
  113.    m 2 3 r8                 c_assgn(ztmp2, ARR2D(ww2, ij, is, ldww2));
  114.    m 2 3 r8                 c_mul3v(ztmp1, ztmp3, ztmp2);
  115.    m 2 3 r8     
  116.    m 2 3 r8                 c_assgn(ztmp3, ARR2D(ww3, ik, ir, ldww3));
  117.    m 2 3 r8                 c_mul3v(ztmp2, ztmp1, ztmp3);
  118.    m 2 3 r8     
  119.    m 2 3 r8                 c_assgn(ztmp1, ARR2D(ww4, ir, is, ldww4));
  120.    m 2 3 r8                 c_mul3v(ztmp3, ztmp2, ztmp1);
  121.    m 2 3 r8     
  122.    m 2 3 r8                 c_assgn(ARR2D(b, i, j, ldb), ztmp3);
  123.    m 2 3 r8--->           }
  124.    m 2 3------>         }
  125.    m 2-------->       }
  126.    m                } else {
  127.    m                  ir = ii / m1;
  128.    m                  ij0 = ii % m1;
  129.    m            
  130.    m                  itmp1 = n2 / m2;
  131.    m Vp-------<       for (is = 0; is < itmp1; ++is) {
  132.    m Vp 3-----<         for (ik = 0; ik < m2; ++ik) {
  133.    m Vp 3                 c_assgn(ztmp1, ARR2D(ww3, ik, ir, ldww3));
  134.    m Vp 3                 c_assgn(ztmp2, ARR2D(ww4, ir, is, ldww4));
  135.    m Vp 3                 c_mul3v(ztmp4, ztmp1, ztmp2);
  136.    m Vp 3                 j = ik + is * m2;
  137.    m Vp 3                 ij = ij0;
  138.    m Vp 3       
  139.    m Vp 3                 tmin1 = ii + FFTE_NBLK;
  140.    m Vp 3                 V2MIN( tmin1, n1 );
  141.    m Vp 3 Vp--<           for (i = ii; i < tmin1; ++i) {
  142.    m Vp 3 Vp                c_assgn(ztmp1, ARR2D(ww1, ij, ik, ldww1));
  143.    m Vp 3 Vp                c_assgn(ztmp2, ARR2D(ww2, ij, is, ldww2));
  144.    m Vp 3 Vp                c_mul3v(ztmp3, ztmp1, ztmp2);
  145.    m Vp 3 Vp    
  146.    m Vp 3 Vp                c_mul3v(ztmp1, ztmp3, ztmp4);
  147.    m Vp 3 Vp    
  148.    m Vp 3 Vp                c_assgn(ztmp2, ARR2D(c, j, i-ii, ldc));
  149.    m Vp 3 Vp                c_mul3v(ztmp3, ztmp2, ztmp1);
  150.    m Vp 3 Vp    
  151.    m Vp 3 Vp                c_assgn(ARR2D(b, i, j, ldb), ztmp3);
  152.    m Vp 3 Vp    
  153.    m Vp 3 Vp                ++ij;
  154.    m Vp 3 Vp-->           }
  155.    m Vp 3----->         }
  156.    m Vp------->       }
  157.    m                }
  158.    m---------->   }
  159.                 
  160.                 #ifdef _OPENMP
  161.                 #pragma omp for private(i,j,tmin1)
  162.                 #endif
  163.  + m----------<   for (jj = 0; jj < n2; jj += FFTE_NBLK) {
  164.    m                tmin1 = jj + FFTE_NBLK;
  165.    m                V2MIN(tmin1, n2);
  166.  + m 2--------<     for (j = jj; j < tmin1; ++j) {
  167.  + m 2                HPCC_fft235( PTR2D(b, 0, j, ldb), c, w1, n1, ip1 );
  168.    m 2-------->     }
  169.    m            
  170.  + m 2--------<     for (i = 0; i < n1; ++i)
  171.  + m 2 r8-----<       for (j = jj; j < tmin1; ++j) {
  172.    m 2 r8               c_assgn(ARR2D(a2, j, i, lda2), ARR2D(b, i, j, ldb));
  173.    m 2 r8---->>       }
  174.    m---------->   }
  175.                 
  176.                   return 0;
  177.                 }
  178.                 
  179.                 static int
  180.                 settbls(fftw_complex *w1, fftw_complex *w2, fftw_complex *w3, fftw_complex *w4,
  181.                   int n1, int n2, int m1, int m2) {
  182.                 
  183.                   int j, k, is, ir;
  184.                   int ldw1, ldw2, ldw3, ldw4;
  185.                   double pi2, px;
  186.                 
  187.                   pi2 = 8.0 * atan(1.0);
  188.                   px = -pi2 / n1 / n2;
  189.                 
  190.                   ldw1 = m1;
  191.                   ldw2 = m1;
  192.                   ldw3 = m2;
  193.                   ldw4 = n1/m1;
  194.                 
  195.                 #ifdef _OPENMP
  196.                 #pragma omp parallel
  197.    M----------<   {
  198.    M            #pragma omp for private(j, ir)
  199.    M            #endif
  200.  + M m--------<   for (k = 0; k < m2; ++k) {
  201.  + M m r5-----<     for (j = 0; j < m1; ++j) {
  202.  + M m r5             c_re(ARR2D(w1, j, k, ldw1)) = cos(px * j * k);
  203.    M m r5             c_im(ARR2D(w1, j, k, ldw1)) = sin(px * j * k);
  204.    M m r5----->     }
  205.    M m          
  206.    M m Vpr2---<     for (ir = 0; ir < n1/m1; ++ir) {
  207.  + M m Vpr2           c_re(ARR2D(w3, k, ir, ldw3)) = cos(px * k * ir * m1);
  208.    M m Vpr2           c_im(ARR2D(w3, k, ir, ldw3)) = sin(px * k * ir * m1);
  209.    M m Vpr2--->     }
  210.    M m-------->   }
  211.    M            
  212.    M            #ifdef _OPENMP
  213.    M            #pragma omp for private(j, ir)
  214.    M            #endif
  215.  + M m--------<   for (is = 0; is < n2/m2; ++is) {
  216.  + M m r5-----<     for (j = 0; j < m1; ++j) {
  217.  + M m r5             c_re(ARR2D(w2, j, is, ldw2)) = cos(px * j * is * m2);
  218.    M m r5             c_im(ARR2D(w2, j, is, ldw2)) = sin(px * j * is * m2);
  219.    M m r5----->     }
  220.    M m          
  221.  + M m r5-----<     for (ir = 0; ir < n1/m1; ++ir) {
  222.  + M m r5             c_re(ARR2D(w4, ir, is, ldw4)) = cos(px * ir * m1 * is * m2);
  223.    M m r5             c_im(ARR2D(w4, ir, is, ldw4)) = sin(px * ir * m1 * is * m2);
  224.    M m r5----->     }
  225.    M m-------->   }
  226.    M            #ifdef _OPENMP
  227.    M---------->   }
  228.                 #endif
  229.                 
  230.                   return 0;
  231.                 }	/* settbls */
  232.                 
  233.                 int
  234.                 HPCC_zfft1d(int n, fftw_complex *a, fftw_complex *b, int iopt, hpcc_fftw_plan p) {
  235.                   int i;
  236.                   int m1, m2, n1, n2, nd;
  237.                   double dn;
  238.                   int ip[3], ip1[3], ip2[3];
  239.                   fftw_complex *w1, *w2, *ww1, *ww2, *ww3, *ww4, *c, *d;
  240.                 
  241.                   w1 = p->w1;
  242.                   w2 = p->w2;
  243.                   ww1 = p->ww1;
  244.                   ww2 = p->ww2;
  245.                   ww3 = p->ww3;
  246.                   ww4 = p->ww4;
  247.                   c = p->c;
  248.                   d = p->d;
  249.                 
  250.  +                HPCC_factor235( n, ip );
  251.                 
  252.                   if (1 == iopt)
  253.  + r8---------<     for (i = 0; i < n; ++i) {
  254.    r8                 c_im( a[i] ) = -c_im( a[i] );
  255.    r8--------->     }
  256.                 
  257.                   if (n <= FFTE_L2SIZE / 16 / 3 && n <= FFTE_NDA2) {
  258.                     if (0 == iopt) {
  259.  +                    HPCC_settbl( w1, n );
  260.                       return 0;
  261.                     }
  262.                 
  263.  +                  HPCC_fft235( a, b, w1, n, ip );
  264.                   } else {
  265.  + w----------<     for (i = 0; i < 3; ++i) {
  266.    w                  ip1[i] = (ip[i] + 1) / 2;
  267.    w                  ip2[i] = ip[i] - ip1[i];
  268.    w---------->     }
  269.                 
  270.    D I-------->     n1 = HPCC_ipow( 2, ip1[0] ) * HPCC_ipow( 3, ip1[1] ) * HPCC_ipow( 5, ip1[2] );
  271.    D I-------->     n2 = HPCC_ipow( 2, ip2[0] ) * HPCC_ipow( 3, ip2[1] ) * HPCC_ipow( 5, ip2[2] );
  272.                 
  273.    D I-------->     if (HPCC_ipow( 2, ip1[0] ) < FFTE_NBLK || HPCC_ipow( 2, ip2[0] ) < FFTE_NBLK) {
  274.    D I-------->       m1 = HPCC_ipow( 2, ip1[0] / 2 ) * HPCC_ipow( 3, ip1[1] / 2 ) * HPCC_ipow( 5, ip1[2] / 2 );
  275.                 
  276.    D I-------->       m2 = HPCC_ipow( 2, ip2[0] / 2 ) * HPCC_ipow( 3, ip2[1] / 2 ) * HPCC_ipow( 5, ip2[2] / 2 );
  277.                     } else {
  278.    D I-------->       m1 = HPCC_ipow( 2, ip1[0] / 2);
  279.                       m1 = FFTE_NBLK > m1 ? FFTE_NBLK : m1;
  280.                 
  281.    D I-------->       m2 = HPCC_ipow( 2, ip2[0] / 2);
  282.                       m2 = FFTE_NBLK > m2 ? FFTE_NBLK : m2;
  283.                     }
  284.                     V2MIN( m1, n1 );
  285.                     V2MIN( m2, n2 );
  286.                 
  287.                     if (0 == iopt) {
  288.  +                    HPCC_settbl( w1, n1 );
  289.  +                    HPCC_settbl( w2, n2 );
  290.  +                    settbls( ww1, ww2, ww3, ww4, n1, n2, m1, m2 );
  291.                       return 0;
  292.                     }
  293.                 
  294.                     nd = (n2 + FFTE_NP) * FFTE_NBLK + FFTE_NP;
  295.                 
  296.                 #ifdef _OPENMP
  297.                 #pragma omp parallel private(c,i)
  298.    M----------<    {
  299.  + M                i = omp_get_thread_num();
  300.    M                c = p->c + i*p->c_size;
  301.    M                d = p->d + i*p->d_size;
  302.    M            #endif
  303.    M            
  304.  + M                zfft1d0( a, a, b, c, d, w1, w2, ww1, ww2, ww3, ww4, n1, n2, m1, m2, ip1, ip2 );
  305.    M            
  306.    M            #ifdef _OPENMP
  307.    M---------->    }
  308.                 #endif
  309.                 
  310.                   }
  311.                 
  312.                   if (1 == iopt) {
  313.  +                  dn = 1.0 / (double)n;
  314.  + r8---------<     for (i = 0; i < n; ++i) {
  315.    r8                 c_re( a[i] ) *= dn;
  316.    r8                 c_im( a[i] ) *= -dn;
  317.    r8--------->     }
  318.                   }
  319.                 
  320.                   return 0;
  321.                 }	/* HPCC_zfft1d */

CC-6002 CC: SCALAR File = zfft1d.c, Line = 50 
  A loop was eliminated by optimization.

CC-6287 CC: VECTOR File = zfft1d.c, Line = 76 
  A loop was not vectorized because it contains a call to function "HPCC_fft235" on line 94.

CC-6817 CC: THREAD File = zfft1d.c, Line = 76 
  A loop was partitioned.

CC-6254 CC: VECTOR File = zfft1d.c, Line = 77 
  A loop was not vectorized because a recurrence was found on "c" at line 86.

CC-6294 CC: VECTOR File = zfft1d.c, Line = 81 
  A loop was not vectorized because a better candidate was found at line 85.

CC-6332 CC: VECTOR File = zfft1d.c, Line = 85 
  A loop was not vectorized because it does not map well onto the target architecture.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 85 
  A loop was unrolled 8 times.

CC-6287 CC: VECTOR File = zfft1d.c, Line = 93 
  A loop was not vectorized because it contains a call to function "HPCC_fft235" on line 94.

CC-3021 CC: IPA File = zfft1d.c, Line = 94 
  "HPCC_fft235" (called from "zfft1d0") was not inlined because the compiler was unable to locate the routine.

CC-6002 CC: SCALAR File = zfft1d.c, Line = 96 
  A loop was eliminated by optimization.

CC-3001 CC: IPA File = zfft1d.c, Line = 96 
  The call to leaf routine "HPCC_ipow" was textually inlined.

CC-3001 CC: IPA File = zfft1d.c, Line = 96 
  The call to leaf routine "HPCC_ipow" was textually inlined.

CC-6294 CC: VECTOR File = zfft1d.c, Line = 98 
  A loop was not vectorized because a better candidate was found at line 104.

CC-6294 CC: VECTOR File = zfft1d.c, Line = 99 
  A loop was not vectorized because a better candidate was found at line 104.

CC-6332 CC: VECTOR File = zfft1d.c, Line = 104 
  A loop was not vectorized because it does not map well onto the target architecture.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 104 
  A loop was unrolled 8 times.

CC-6217 CC: VECTOR File = zfft1d.c, Line = 131 
  A loop was partially and conditionally vectorized.

CC-6208 CC: VECTOR File = zfft1d.c, Line = 132 
  A loop was vectorized as part of the loop starting at line 131.

CC-6209 CC: VECTOR File = zfft1d.c, Line = 141 
  A loop was partially vectorized.

CC-6287 CC: VECTOR File = zfft1d.c, Line = 163 
  A loop was not vectorized because it contains a call to function "HPCC_fft235" on line 167.

CC-6817 CC: THREAD File = zfft1d.c, Line = 163 
  A loop was partitioned.

CC-6287 CC: VECTOR File = zfft1d.c, Line = 166 
  A loop was not vectorized because it contains a call to function "HPCC_fft235" on line 167.

CC-3021 CC: IPA File = zfft1d.c, Line = 167 
  "HPCC_fft235" (called from "zfft1d0") was not inlined because the compiler was unable to locate the routine.

CC-6294 CC: VECTOR File = zfft1d.c, Line = 170 
  A loop was not vectorized because a better candidate was found at line 171.

CC-6332 CC: VECTOR File = zfft1d.c, Line = 171 
  A loop was not vectorized because it does not map well onto the target architecture.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 171 
  A loop was unrolled 8 times.

CC-6823 CC: THREAD File = zfft1d.c, Line = 197 
  A region starting at line 197 and ending at line 227 was multi-threaded.

CC-6294 CC: VECTOR File = zfft1d.c, Line = 200 
  A loop was not vectorized because a better candidate was found at line 201.

CC-6817 CC: THREAD File = zfft1d.c, Line = 200 
  A loop was partitioned.

CC-6332 CC: VECTOR File = zfft1d.c, Line = 201 
  A loop was not vectorized because it does not map well onto the target architecture.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 201 
  A loop was unrolled 5 times.

CC-6009 CC: SCALAR File = zfft1d.c, Line = 202 
  A floating point expression involving an induction variable was strength reduced by optimization.  This may cause numerical
  differences.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 206 
  A loop was unrolled 2 times.

CC-6209 CC: VECTOR File = zfft1d.c, Line = 206 
  A loop was partially vectorized.

CC-6009 CC: SCALAR File = zfft1d.c, Line = 207 
  A floating point expression involving an induction variable was strength reduced by optimization.  This may cause numerical
  differences.

CC-6294 CC: VECTOR File = zfft1d.c, Line = 215 
  A loop was not vectorized because a better candidate was found at line 216.

CC-6817 CC: THREAD File = zfft1d.c, Line = 215 
  A loop was partitioned.

CC-6332 CC: VECTOR File = zfft1d.c, Line = 216 
  A loop was not vectorized because it does not map well onto the target architecture.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 216 
  A loop was unrolled 5 times.

CC-6009 CC: SCALAR File = zfft1d.c, Line = 217 
  A floating point expression involving an induction variable was strength reduced by optimization.  This may cause numerical
  differences.

CC-6332 CC: VECTOR File = zfft1d.c, Line = 221 
  A loop was not vectorized because it does not map well onto the target architecture.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 221 
  A loop was unrolled 5 times.

CC-6009 CC: SCALAR File = zfft1d.c, Line = 222 
  A floating point expression involving an induction variable was strength reduced by optimization.  This may cause numerical
  differences.

CC-3021 CC: IPA File = zfft1d.c, Line = 250 
  "HPCC_factor235" (called from "HPCC_zfft1d") was not inlined because the compiler was unable to locate the routine.

CC-6332 CC: VECTOR File = zfft1d.c, Line = 253 
  A loop was not vectorized because it does not map well onto the target architecture.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 253 
  A loop was unrolled 8 times.

CC-3021 CC: IPA File = zfft1d.c, Line = 259 
  "HPCC_settbl" (called from "HPCC_zfft1d") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = zfft1d.c, Line = 263 
  "HPCC_fft235" (called from "HPCC_zfft1d") was not inlined because the compiler was unable to locate the routine.

CC-6271 CC: VECTOR File = zfft1d.c, Line = 265 
  A loop was not vectorized because its trip count is too small.

CC-6008 CC: SCALAR File = zfft1d.c, Line = 265 
  A loop was unwound.

CC-6002 CC: SCALAR File = zfft1d.c, Line = 270 
  A loop was eliminated by optimization.

CC-3001 CC: IPA File = zfft1d.c, Line = 270 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 270 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 270 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-6002 CC: SCALAR File = zfft1d.c, Line = 271 
  A loop was eliminated by optimization.

CC-3001 CC: IPA File = zfft1d.c, Line = 271 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 271 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 271 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-6002 CC: SCALAR File = zfft1d.c, Line = 273 
  A loop was eliminated by optimization.

CC-3001 CC: IPA File = zfft1d.c, Line = 273 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 273 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-6002 CC: SCALAR File = zfft1d.c, Line = 274 
  A loop was eliminated by optimization.

CC-3001 CC: IPA File = zfft1d.c, Line = 274 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 274 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 274 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-6002 CC: SCALAR File = zfft1d.c, Line = 276 
  A loop was eliminated by optimization.

CC-3001 CC: IPA File = zfft1d.c, Line = 276 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 276 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3001 CC: IPA File = zfft1d.c, Line = 276 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-6002 CC: SCALAR File = zfft1d.c, Line = 278 
  A loop was eliminated by optimization.

CC-3001 CC: IPA File = zfft1d.c, Line = 278 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-6002 CC: SCALAR File = zfft1d.c, Line = 281 
  A loop was eliminated by optimization.

CC-3001 CC: IPA File = zfft1d.c, Line = 281 
  The call to leaf routine "HPCC_ipow" was textually inlined due to constant actual(s).

CC-3021 CC: IPA File = zfft1d.c, Line = 288 
  "HPCC_settbl" (called from "HPCC_zfft1d") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = zfft1d.c, Line = 289 
  "HPCC_settbl" (called from "HPCC_zfft1d") was not inlined because the compiler was unable to locate the routine.

CC-3171 CC: IPA File = zfft1d.c, Line = 290 
  "settbls" (called from "HPCC_zfft1d") was not inlined because it is not in the body of a loop.

CC-6823 CC: THREAD File = zfft1d.c, Line = 298 
  A region starting at line 298 and ending at line 307 was multi-threaded.

CC-3021 CC: IPA File = zfft1d.c, Line = 299 
  "omp_get_thread_num" (called from "HPCC_zfft1d") was not inlined because the compiler was unable to locate the routine.

CC-3005 CC: IPA File = zfft1d.c, Line = 304 
  "zfft1d0" (called from "HPCC_zfft1d") was not inlined because the type of argument 16 does not match the corresponding type from
  the routine definition - RESTRICT qualifiers differ.

CC-6010 CC: SCALAR File = zfft1d.c, Line = 313 
  A divide was turned into a multiply by a reciprocal

CC-6332 CC: VECTOR File = zfft1d.c, Line = 314 
  A loop was not vectorized because it does not map well onto the target architecture.

CC-6005 CC: SCALAR File = zfft1d.c, Line = 314 
  A loop was unrolled 8 times.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
